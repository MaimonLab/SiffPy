# SIFFPY

Python and C++ code for working with .tiffs generated by ScanImage and .siffs generated by my custom modified ScanImage (currently reachable at https://github.com/maimonlab/ScanImage2020). In my tests, handles files faster and more gracefully than ScanImage's tiffreader (possibly because it performs fewer checks -- my files are not as diverse).

### TODOS:
-    Add support for multi-ROI imaging.
-    Implement plotting functionality.
-    Registration in pure C

## Installing SiffPy

Should work if you simply run `python setup.py install` in your conda environment of your choice. Requires numpy. To really spell it out:

- Open a terminal and navigate to where you'd like to copy the SiffPy files with `cd` (e.g. `cd ~/Downloads`).
- Clone the repo a location of your choosing with `git clone https://github.com/maimonlab/SiffPy`
- Enter the newly created directory with `cd SiffPy`.
- Make sure you're in the environment you want, e.g. by typing `source activate flim`. You want to use one where the base Python install is Python3. I intend to integrate `suite2p` registration into this code, so to be compatible with that I recommend using `>3.9`.
- Type `python setup.py install`.

If you don't have numpy, it will complain during install and tell you to install `numpy` first (rather than downloading it yourself). To do so, you can either install it with `pip` by typing `pip install numpy` or with `conda` by typing `conda install -c anaconda numpy`. Uses only basic `numpy` includes, so version won't matter. 

This will compile the C extension module `siffreadermodule` that does most of the heavy lifting, stick the library into your path for this environment, and then make the SiffPy Python code accessible.

## Using SiffPy

The primary object in `SiffPy` is the `SiffReader` class, which is usually imported with `from siffpy import SiffReader` at the start of a notebook. A `SiffReader` object handles I/O with a .siff or .tiff file to keep track of important file-specific variables as well as implements much of the boilerplate sort of code. A typical very simple use case would look like:
```
from siffpy import SiffReader
import siffpy

sr = SiffReader()
filename = "path\to\my\file"
sr.open(filename)

# Let's check the most important image parameters
print(sr.im_params)

# Pool the first 100 timepoints for all stacks in a z-stack, but only in the first color channel
T_START = 0
T_END = 101
POOL_WIDTH = 100

# list of frames
pooled_frames = sr.sum_across_time(timepoint_start = T_START, timepoint_end = T_END, timespan=POOL_WIDTH, flim=False, color_list = [0])

# get just photon arrival times from the first 1000 frames

histogram = sr.get_histogram(frames=list(range(0,1000)))

# now let's fit a biexponential distribution to the data

# for some fluorophores, I have some pre-stored fits that are useful for the nonlinear optimization.
# to see which ones are available:

import siffutils # some simple useful tools relating to fluorophores
print(siffutils.available_fluorophores())

fit_list = siffpy.fit_exp(histogram, fluorophores=['gCamui']) # returns a list of FLIMParams object for each element
# of histogram. Since histogram is 1 element this will just return one. 

print(fit_list[0].param_dict())

# just to check the fit (siffplot will implement a nicer version of this eventually):
import matplotlib.pyplot as plt

MAX_NUMBER_BINS=1024 # this is hardcoded at the moment, with siffreadermodule return a FLIM dimension of size 1024
plt.semilogy(histogram)
plt.semilogy(fit_list[0].p_dist(np.arange(MAX_NUMBER_BINS)))


# Return three x-dim by y-dim arrays: a map of empirical lifetimes (in units of histogram BINS, will be converted to nanoseconds in later implementations), the regular pixelwise number of photons, and a confidence metric reflecting how well-fit the data are by our overall FLIM fitting procedure. Noise pixels will be poorly fit while signal pixels will show good quality fits. Here we'll use the chi-squared statistic.

(flim_map, intensity, chi_sq) = siffreader.flim_map(fit_list[0], frames=[list(range(4,15000,10)) + list(range(3,15000,10))],confidence_metric='chi_sq')

# mask the data by how informative each pixel is about a fluoroscence lifetime measurement
import scipy.stats as stats
alphas = 1.0 - stats.chi2.cdf(chi_sq,600) # the 600 will be replaced by a param from the siff file soon.

BIN_WIDTH = 0.02 # (nanoseconds per bin)

plt.figure()
ax = plt.axes()
ax.set_facecolor("black")
plt.imshow(BIN_WIDTH*flim_map, alpha=alphas, vmin=1.0, vmax=2.0) # colormap goes from 1.0 to 2.0 nanoseconds.

plt.figure()
plt.imshow(intensity)
```

### Handling data

FLIM data is mostly naturally stored in sparse arrays: most pixels are not important, most histogram bins do not have many entries. But once you start building 512 by 512 pixel arrays, each of which have a FLIM measurement depth of 1024 bins, the array sizes get large quickly (one frame of this size would be 536 MB... acquiring at 30 Hz would give you a 16GB array for every one second of imaging). Most of SiffPy's functionality is performed lazily, avoiding loading arrays into memory unless some pixelwise relationship between several arrays is really needed. The `siffreader` C++ module mostly takes a `frames` or `frameslists` argument that allows pooling of frames by index, and the `siffpy` Python API does its best to hide all the nitty-gritty of that process from the user.

### More direct access to the data

The `siffreader` module contains lower-level access to the data, allowing you to directly get numpy arrays from .siff and .tiff files. To learn more, type `import siffreader; help(siffreader)` in your Python interpreter or in a Jupyter notebook.

Note:
So far I've only really been testing functionality in Jupyter notebooks. Note that if you use Jupyter lab, there are a few incompatibilities with the plotting libraries `matplotlib`, `bokeh`, and `holoviews`. However, the core code for extracting the data will be unaffected and relies ONLY on `numpy`.

