# SIFFPY

Python and C++ code for working with .tiffs generated by ScanImage and .siffs generated by my custom modified ScanImage (currently reachable at https://github.com/maimonlab/ScanImage2020). In my tests, handles files faster and more gracefully than ScanImage's tiffreader (possibly because it performs fewer checks -- my files are not as diverse).

### TODOS:
-    Add support for multi-ROI imaging.
-    Use cumulative bin occupancy not point estimates in chi-sq
-    Registration in pure C?
-    Update example code to include image registration + diagnostics
-    Batching in registration alignment to take advantage of FFT scaling without massive memory issues
-    Improved regularization in registration, especially for systematically bad planes
-    Speed up registration, e.g. move the convolution into the Fourier domain (might speed things up a lot)
-    Sphinx documentation + tutorial .ipynb

## Installing SiffPy

Should work if you simply run `python setup.py install` in your conda environment of your choice. Requires numpy. To really spell it out:

- Open a terminal and navigate to where you'd like to copy the SiffPy files with `cd` (e.g. `cd ~/Downloads`).
- Clone the repo a location of your choosing with `git clone https://github.com/maimonlab/SiffPy`
- Enter the newly created directory with `cd SiffPy`.
- Make sure you're in the environment you want, e.g. by typing `source activate flim`. You want to use one where the base Python install is Python3. I've been using `>3.9` with `futures` but none of that seems essential.
- Type `python setup.py install`.

If you don't have numpy, it will complain during install and tell you to install `numpy` first (rather than downloading it yourself). To do so, you can either install it with `pip` by typing `pip install numpy` or with `conda` by typing `conda install -c anaconda numpy`. Uses only basic `numpy` includes, so version won't matter. 

This will compile the C extension module `siffreadermodule` that does most of the heavy lifting, stick the library into your path for this environment, and then make the SiffPy Python code accessible.

Image registration is currently done in numpy but does not require loading the whole dataset into memory.
For now, it just does alignment using the intensity images, rather than
considering what source a photon is likely to have arrived from using FLIM.

## Using SiffPy

The primary object in `SiffPy` is the `SiffReader` class, which is usually imported with `from siffpy import SiffReader` at the start of a notebook. A `SiffReader` object handles I/O with a .siff or .tiff file to keep track of important file-specific variables as well as implements much of the boilerplate sort of code.

There are several submodules, each specializing in different tasks. Each has its own README.md file that explains more.

### SiffPlot

This submodule handles visualization of data from .siff files.

### SiffTrac

This submodule handles alignment with FicTrac output datasets and visualization of the relationship
between FicTrac data and SiffReader data.

### SiffUtils

This submodule handles functionality related to FLIM data, such as multiexponential fitting, and
functionality related to image processing, such as image registration.

### Handling data

FLIM data is mostly naturally stored in sparse arrays: most pixels are not important, most histogram bins do not have many entries. But once you start building 512 by 512 pixel arrays, each of which have a FLIM measurement depth of 1024 bins, the array sizes get large quickly (one frame of this size would be 536 MB... acquiring at 30 Hz would give you a 16GB array for every one second of imaging). Most of SiffPy's functionality is performed lazily, avoiding loading arrays into memory unless some pixelwise relationship between several arrays is really needed. The `siffreader` C++ module mostly takes a `frames` or `frameslists` argument that allows pooling of frames by index, and the `siffpy` Python API does its best to hide all the nitty-gritty of that process from the user.

### More direct access to the data

The `siffreader` module contains lower-level access to the data, allowing you to directly get numpy arrays from .siff and .tiff files. To learn more, type `import siffreader; help(siffreader)` in your Python interpreter or in a Jupyter notebook.

Note:
So far I've only really been testing functionality in Jupyter notebooks. Note that if you use Jupyter lab, there are a few incompatibilities with the plotting libraries `matplotlib`, `bokeh`, and `holoviews`. However, the core code for extracting the data will be unaffected and relies ONLY on `numpy`.

