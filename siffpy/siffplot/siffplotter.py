"""
Class and functions relating to the SiffPlotter, a class
which produces figures, pre or post analysis, of fluorescence
data stored in .siff and .tiff files that can be read by the
SiffReader class of the main siffpy module

SCT 09/23/2021
"""
import os,logging, pickle
import warnings

import holoviews as hv

from .roi_protocols import rois
from ..siffpy import SiffReader
from .utils import *

def apply_opts(func):
    """
    Decorator function to apply a SiffPlotter's
    'local_opts' attribute to methods which return
    objects that might want them. Allows this object
    to supercede applied defaults, because this gets
    called with every new plot. Does nothing if local_opts
    is not defined.
    """
    def local_opts(*args, **kwargs):
        if hasattr(args[0],'local_opts'):
            try:
                opts = args[0].local_opts # get the local_opts param from self
                return func(*args, **kwargs).opts(*opts)
            except:
                return func(*args, **kwargs)
        else:
            return func(*args, **kwargs)
    return local_opts

class SiffPlotter():
    """
    The core SiffPlotter object. Contains and tracks ROIs, annotations, and has
    methods for producing and modifying those.

    Attributes
    ----------

    local_opts : hv.opts

        Local opts that are applied specifically to plots coming from
        this SiffPlotter

    rois : list[siffplot.roi_protocols.rois.ROI]

        A list of the rois annotated, extracted, stored, and/or loaded by this SiffPlotter.
        To learn more about these, look at the documentation for the ROI class (and its subclasses).

    """

    def __init__(self, siffreader : SiffReader, *args, **kwargs):
        """
        Possible initializations:

        SiffPlotter(siffreader : siffpy.SiffReader, **kwargs)

            - Initializes a generic SiffPlotter class, identifying
            reference frames, searching for accompanying saved ROIs,
            and selecting a viewer backend.
        
        HIDDEN KWARGS
        ------

        local_opts : iterable

            Accepts opts keyword with an unpackable iterable used for
            all plots generated by this object

        """
        self.siffreader : SiffReader = siffreader
        self.reference_frames = None

        try:
            # can only be run if hv.extension(backend) has been executed
            if 'opts' in kwargs:
                if not isinstance(kwargs['opts'], (list, tuple)):
                    TypeError("Argument opts only accepts tuples or lists -- something that can be unpacked")
                self.local_opts = kwargs['opts']
            else:
                # Default opts
                self.local_opts = [
                    hv.opts.Image(
                        cmap='viridis',
                        invert_yaxis=True,
                        width=self.siffreader.im_params.xsize,
                        height=self.siffreader.im_params.ysize,
                        #hooks = [bounds_hook]
                    )
                ]
        except AttributeError:
            warnings.warn("HoloViews not yet initialized, and so local_opts was not defined.")

        if self.siffreader.opened:
            self.reference_frames : hv.HoloMap = self.reference_frames_to_holomap()

        directory_with_file_name = os.path.join(
            os.path.dirname(self.siffreader.filename),
            os.path.splitext(self.siffreader.filename)[0]
        )

        if os.path.exists(directory_with_file_name):
            if any([file.endswith('.roi') for file in os.listdir(directory_with_file_name)]):
                logging.warning("Found .roi file(s) in directory with open file.\nLoading ROI(s)")
                self.load_rois(path = directory_with_file_name)

    @apply_opts
    def reference_frames_to_holomap(self)->hv.HoloMap:
        """
        If the current siffreader has an opened file,
        looks to see if there are stored reference frames,
        and if so returns a HoloViews HoloMap that allows
        viewing each of them
        """
        if not hasattr(self.siffreader, 'reference_frames'):
            logging.warning("No reference frames stored in siffreader")
            return None
        if self.siffreader.reference_frames is None:
            logging.warning("No reference frames stored in siffreader")
            return None
        
        self.ref_ds = hv.Dataset(
            (
                range(self.siffreader.im_params.xsize),
                range(self.siffreader.im_params.ysize), 
                range(self.siffreader.im_params.num_slices),
                self.siffreader.reference_frames
            ),
            ['x','y','z'], 'Intensity'
        )

        ref_holomap = self.ref_ds.to(hv.Image, ['x','y'], 'Intensity', groupby=['z'])
        # hard limits
        if hasattr(self,'local_opts'): # avoids initialization issues.
            ref_holomap = ref_holomap.opts(
                xlim = (0, self.siffreader.im_params.xsize),
                ylim = (0, self.siffreader.im_params.ysize)
            )
            if not self.local_opts is None:
                ref_holomap = ref_holomap.opts(*self.local_opts)
        return ref_holomap

    ## ROIS
    def save_rois(self, path : str = None):
        """
        Saves the rois stored in the self.rois attribute. The default path is in the directory with
        the .siff file.

        Arguments
        ---------
        
        path : str (optional)

            Where to save the ROIs.
        """
        if self.rois is None:
            raise RuntimeError("SiffPlotter object has no rois stored")
        
        if path is None:
            if not self.siffreader.opened:
                raise RuntimeError("Siffreader has no open file, and no alternative path was provided.")
            path = os.path.dirname(self.siffreader.filename)

        path = os.path.join(path, os.path.splitext(os.path.basename(self.siffreader.filename))[0])

        if hasattr(self.rois,'__iter__'):
            for roi in self.rois:
                roi.save(path)
        elif not (self.rois is None):
            # else, just save the one.
            self.rois.save(path)
        else:
            raise AttributeError("No attribute rois defined for this SiffPlotter.")

    def load_rois(self, path : str = None):
        """
        Loads rois stored at location 'path'. If no path is specified, then
        it looks for .roi files matching the file name
        """

        if path is None:
            path = os.path.join(
                os.path.dirname(self.siffreader.filename),
                os.path.splitext(os.path.basename(self.siffreader.filename))[0]
            )
        
        roi_files = [os.path.join(path,file) for file in os.listdir(path) if file.endswith('.roi')]

        self.rois = []
        for roi in roi_files:
            with open(roi, 'rb') as curr_file:
                if type(self.rois) is list:
                    self.rois.append(pickle.load(curr_file))
                elif type(self.rois) is rois.ROI:
                    self.rois = list(self.rois) + [pickle.load(curr_file)]
                else:
                    self.rois = [pickle.load(curr_file)]

    def __getattribute__(self, name: str):
        """
        To make it easier to access when there's only one ROI
        (there's something gross about having to have a bunch of [0]
        sitting around in your code)
        """
        if name == 'rois':
            roi_ref = object.__getattribute__(self, name)
            if type(roi_ref) is list:
                if len(roi_ref) == 1:
                    return roi_ref[0]
            return roi_ref
        else:
            return object.__getattribute__(self, name)