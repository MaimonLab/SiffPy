"""
Class and functions relating to the SiffPlotter, a class
which produces figures, pre or post analysis, of fluorescence
data stored in .siff and .tiff files that can be read by the
SiffReader class of the main siffpy module

SCT 09/23/2021
"""
from abc import abstractmethod
import os,logging, pickle
import warnings
from functools import wraps

import holoviews as hv
from holoviews.core.io import Pickler, Unpickler

from .roi_protocols import rois
from .utils import *

from ..core import SiffReader
from ..core.io.events import SiffEvent

def apply_opts(func):
    """
    Decorator function to apply a SiffPlotter's
    'local_opts' attribute to methods which return
    objects that might want them. Allows this object
    to supercede applied defaults, because this gets
    called with every new plot. Does nothing if local_opts
    is not defined.
    """
    @wraps(func)
    def local_opts(*args, **kwargs):
        if hasattr(args[0],'_local_opts'):
            try:
                opts = args[0]._local_opts # get the local_opts param from self
                if isinstance(opts, list):
                    return func(*args, **kwargs).opts(*opts)
                if isinstance(opts, dict):
                    return func(*args, **kwargs).opts(opts)
            except:
                return func(*args, **kwargs)
        else:
            return func(*args, **kwargs)
    return local_opts

def apply_events(func):
    """
    Decorator function that checks if any of the events
    stored in the plotter can be overlaid on the plot
    being produced.
    """
    @wraps(func)
    def iterate_through_events(*args, **kwargs):
        self = args[0]
        if not isinstance(self, SiffPlotter):
            raise ValueError("""
                apply_events decorator must be restricted to SiffPlotters
            """)
        if not hasattr(self, 'events'):
            return func(*args, **kwargs)
        else:
            if not isinstance(self.events, list):
                return func(*args, **kwargs)

            output = func(*args, **kwargs)
            for event in self.events:
                if hasattr(event, 'visualize'):
                    output *= event.visualize()
            return output

    return iterate_through_events


class SiffPlotter():
    """
    The core SiffPlotter object. Contains and tracks ROIs, annotations, and has
    methods for producing and modifying those.

    Attributes
    ----------

    local_opts : hv.opts

        Local opts that are applied specifically to plots coming from
        this SiffPlotter

    rois : list[siffplot.roi_protocols.rois.ROI]

        A list of the rois annotated, extracted, stored, and/or loaded by this SiffPlotter.
        To learn more about these, look at the documentation for the ROI class (and its subclasses).

    """

    DEFAULT_OPTS = {
        'Image' : {
            'cmap' : 'viridis',
            'invert_yaxis' : True,
            #hooks = [bounds_hook]
        }
    }

    def __init__(self, siffreader : SiffReader, *args, **kwargs):
        """
        Possible initializations:

        SiffPlotter(siffreader : siffpy.SiffReader, **kwargs)

            - Initializes a generic SiffPlotter class, identifying
            reference frames, searching for accompanying saved ROIs,
            and selecting a viewer backend.
        
        HIDDEN KWARGS
        ------

        opts : iterable

            Accepts opts keyword with an unpackable iterable used for
            all plots generated by this object

        """
        self.siffreader : SiffReader = siffreader
        self.reference_frames = None
        if 'opts' in kwargs:
            if not isinstance(kwargs['opts'], dict):
                raise ValueError("Must pass dictionary for keyword argument opts")
            self._local_opts = kwargs['opts']
        else:
            self._local_opts = SiffPlotter.DEFAULT_OPTS
        self.events = []
        self.data = None

        if self.siffreader.opened:
            self.reference_frames : hv.HoloMap = self.reference_frames_to_holomap()

        directory_with_file_name = os.path.join(
            os.path.dirname(self.siffreader.filename),
            os.path.splitext(self.siffreader.filename)[0]
        )

        if os.path.exists(directory_with_file_name):
            if any([file.endswith('.roi') for file in os.listdir(directory_with_file_name)]):
                logging.warning("Found .roi file(s) in directory with open file.\nLoading ROI(s)")
                self.load_rois(path = directory_with_file_name)

    @apply_opts
    @apply_events
    @abstractmethod
    def visualize(self, color : 'int|list[int]' = None, text : bool = True) -> hv.Layout:
        """
        Visualize the associated phenomena of this SiffPlotter. Must be implemented by subclasses.
        """
        raise NotImplementedError()

    @apply_opts
    def reference_frames_to_holomap(self)->hv.HoloMap:
        """
        If the current siffreader has an opened file,
        looks to see if there are stored reference frames,
        and if so returns a HoloViews HoloMap that allows
        viewing each of them
        """
        if not hasattr(self.siffreader, 'reference_frames'):
            logging.warning("No reference frames stored in siffreader")
            return None
        if self.siffreader.reference_frames is None:
            logging.warning("No reference frames stored in siffreader")
            return None
        
        self.ref_ds = hv.Dataset(
            (
                range(self.siffreader.im_params.xsize),
                range(self.siffreader.im_params.ysize), 
                range(self.siffreader.im_params.num_slices),
                self.siffreader.reference_frames
            ),
            ['x','y','z'], 'Intensity'
        )

        ref_holomap = self.ref_ds.to(hv.Image, ['x','y'], 'Intensity', groupby=['z'])
        # hard limits
        if hasattr(self,'_local_opts'): # avoids initialization issues.
            ref_holomap = ref_holomap.opts(
                xlim = (0, self.siffreader.im_params.xsize),
                ylim = (0, self.siffreader.im_params.ysize)
            )
            if not self._local_opts is None:
                ref_holomap = ref_holomap.opts(*self._local_opts)
        return ref_holomap

    def render_plot(self, plot : hv.element.Element, **kwargs):
        """
        Calls hv.render without the user needing to import HoloViews directly.

        This returns an object from the HoloViews backend being utilized (either
        bokeh or matplotlib) for direct customization.
        """
        return hv.render(plot, **kwargs)

    def save_fig(self, *args, path : str = None, filename : str = None, **kwargs):
        """
        Saves a figure file with a given backend using a Holoviews Pickler. Accepts the standard
        `holoviews.core.io.Pickler.save()` args and kwargs, except if a filename or path are not provided
        it drops the object in a subfolder in the directory holding the .siff file.
        """
        if path is None:
            path = os.path.join(
                os.path.dirname(self.siffreader.filename),
                os.path.splitext(self.siffreader.filename)[0],
                self.__class__.__name__ + " plots"
            )

        if not os.path.exists(path):
            os.makedirs(path)
        
        if filename is None:
            filename = self.__class__.__name__ + " plot obj"

        fname = os.path.join(path, filename)
        Pickler.save(*args, fname, **kwargs)

    def save(self, path : str = None, filename : str = None):
        """
        Saves self in .splot file, which can be read with the class method SiffPlotter.load(file).
        If no path is given, saves in .siff file's current directory.
        """
        
        if path is None:
            path = os.path.join(
                os.path.dirname(self.siffreader.filename),
                os.path.splitext(self.siffreader.filename)[0],
                self.__class__.__name__ + " plots"
            )

        if not os.path.exists(path):
            os.makedirs(path)
        
        if filename is None:
            filename = self.__class__.__name__ + " plot obj"

        fname = os.path.join(path, filename)
        fname += ".splot"

        with open(fname, "wb+") as f:
            pickle.dump(self, f)

    @property
    def filename(self)->str:
        """ Get the filename of the .siff file """
        return self.siffreader.filename

    @classmethod
    def load(path : str):
        """ Loads a .splot file to return a SiffPlotter class (which contains method and local plotting options. """
        raise NotImplementedError()

    @classmethod
    def load_fig(cls, path : str, *args, **kwargs) -> hv.Element:
        """ Wraps HoloViews Unpickler's load method"""
        return Unpickler.load(path, *args, **kwargs)    

    ## ROIS
    def save_rois(self, path : str = None):
        """
        Saves the rois stored in the self.rois attribute. The default path is in the directory with
        the .siff file.

        Arguments
        ---------
        
        path : str (optional)

            Where to save the ROIs.
        """
        if self.rois is None:
            raise NoROIException("SiffPlotter object has no rois stored")
        
        if path is None:
            if not self.siffreader.opened:
                raise RuntimeError("Siffreader has no open file, and no alternative path was provided.")
            path = os.path.dirname(self.siffreader.filename)

        path = os.path.join(path, os.path.splitext(os.path.basename(self.siffreader.filename))[0])

        if hasattr(self.rois,'__iter__'):
            for roi in self.rois:
                roi.save(path)
        elif not (self.rois is None):
            # else, just save the one.
            self.rois.save(path)
        else:
            raise NoROIException("No attribute rois defined for this SiffPlotter.")

    def load_rois(self, path : str = None):
        """
        Loads rois stored at location 'path'. If no path is specified, then
        it looks for .roi files matching the file name
        """

        if path is None:
            path = os.path.join(
                os.path.dirname(self.siffreader.filename),
                os.path.splitext(os.path.basename(self.siffreader.filename))[0]
            )
        
        roi_files = [os.path.join(path,file) for file in os.listdir(path) if file.endswith('.roi')]

        self.rois = []
        for roi in roi_files:
            with open(roi, 'rb') as curr_file:
                if type(self.rois) is list:
                    self.rois.append(pickle.load(curr_file))
                elif issubclass(type(self.rois),rois.ROI):
                    self.rois = list(self.rois) + [pickle.load(curr_file)]
                else:
                    self.rois = [pickle.load(curr_file)]

    def __getattribute__(self, name: str):
        """
        To make it easier to access when there's only one ROI
        (there's something gross about having to have a bunch of [0]
        sitting around in your code)
        """
        if name == 'rois':
            try:
                roi_ref = object.__getattribute__(self, name)
                if type(roi_ref) is list:
                    if len(roi_ref) == 1:
                        return roi_ref[0]
                return roi_ref
            except AttributeError:
                raise NoROIException(f"`{type(self).__name__}` object has no stored ROIs")
        else:
            return object.__getattribute__(self, name)

class EventPlotter():
    """
    A class for taking `siffpy.core.io.events.SiffEvent` subclasses
    and usefully annotating the output of a `SiffPlotter` with them.

    Uses HoloViews for annotation and plotting so it's in the
    same file as the base SiffPlotter class.
    """

    def __init__(self, event : SiffEvent):
        self.event = event

    @abstractmethod
    def visualize(self)->hv.Element:
        """
        This is probably different for every event class.
        """
        raise NotImplementedError()

    @classmethod
    @abstractmethod
    def iscompatible(cls, event : SiffEvent)->bool:
        """ Returns whether an event is compatible with this plotter """
        if not isinstance(event, SiffEvent):
            return False
        return False